## Отчёт по обработке ответа LLM (пост-обработка)

### 1) Краткое резюме
Система получает ответ от внешнего агента (Responses API Yandex Cloud) и преобразует его в текст, пригодный для отправки в Telegram. Ключевые решения: извлечение текстового сообщения из `output`, фильтрация технических/JSON-блоков, обработка ошибок API, сохранение `response_id` для памяти диалога, логирование и отладочная запись «сырых» ответов.

### 2) Поток данных (высокоуровневый)
1. Пользователь → Telegram бот (`bot.py`).
2. Бот вызывает сервис агента (`YandexAgentService.send_to_agent`).
3. Сервис отправляет запрос в Responses API, получает JSON.
4. Сервис извлекает человекочитаемый текст из `result.output[*]` и фильтрует технические ответы.
5. Сервис сохраняет `response_id` в YDB для памяти диалога.
6. Бот отправляет итоговый текст пользователю (Markdown).
7. Параллельно сервис пишет debug-логи «как есть» для диагностики.

### 3) Файлы и ответственность
- `src/services/yandex_agent_service.py` — ядро пост-обработки ответа:
  - Формирование запроса к Responses API (учёт `prompt_id`/`agent_id`, `previous_response_id`).
  - Разбор ответа: поиск последнего «message» в `output`, извлечение `content[0].text`.
  - Фильтрация: игнор JSON-ответов/технических стадий (например, текст, начинающийся с `{` или содержащий ключ `stage`).
  - Ошибки: показ текста ошибки из `result.error.message` либо исключение «Empty response from API».
  - Память: сохранение `response_id` в YDB (`ydb_client.save_response_id`).
  - Метрики/логи: время ответа, идентификатор ответа.

- `bot.py` — доставка ответа пользователю:
  - Получение результата от сервиса агента.
  - Отправка текста в Telegram c `ParseMode.MARKDOWN`.
  - Логирование факта отправки.

- `src/services/debug_service.py` — отладка/диагностика:
  - Сохранение «сырого» JSON-ответа LLM в `debug_logs/llm_response_<chat_id>_<timestamp>.json` без форматирования.

- `src/ydb_client.py` — контекст/память диалога:
  - Хранение и чтение `last_response_id` для `chat_id` (таблица `chat_threads`).

- `service_factory.py` — сборка зависимостей:
  - Создание инстансов `AuthService`, `DebugService`, `YandexAgentService` и пр.

- `src/services/logger_service.py` — единый логгер:
  - Категоризация логов (telegram/api/agent/ydb/debug/error).

### 4) Ключевые разделы кода (логические узлы)
- Извлечение текста из ответа:
  - Поиск с конца по списку `result.output`.
  - Условие `output_item.type == "message"` и наличие `content`.
  - Взятие `content[0].text` как кандидата финального текста.

- Фильтрация нежелательных сегментов:
  - Пропуск JSON/техсообщений: если `text` начинается с `{` или содержит «stage».

- Обработка ошибок:
  - Если нет валидного текста и есть `result.error`, вернуть «⚠️ Ошибка: <message>».
  - Иначе возбуждать исключение «Empty response from API».

- Память ответа:
  - Сохранение `response_id` в YDB после успешного извлечения текста.

- Логирование и метрики:
  - Время обработки, идентификатор ответа, стадии получения/отправки.

### 5) Правила и инварианты пост-обработки
- Финальный текст — последний по времени «message» из `output`, прошедший фильтры.
- JSON-структуры и служебные стадии не показываются пользователю.
- При наличии ошибки API — возвращается человекочитаемое сообщение об ошибке.
- При отсутствии текста и ошибки — фиксируется исключение (диагностика через debug-логи).

### 6) Взаимодействие с окружением и конфигурацией
- Переменные окружения: `RESPONSES_BASE_URL`, `PROMPT_ID`, `YC_AGENT_ID`, токены авторизации/Telegram.
- Хранилище контекста: YDB (таблица `chat_threads` с `chat_id`, `thread_id`, `last_response_id`).
- Логи: папка `debug_logs/` для «сырых» ответов; системные логи через `logger_service`.

### 7) Выходной формат и ограничения
- Текст для Telegram отправляется с `ParseMode.MARKDOWN` — важно, чтобы итог не содержал неэкранированные служебные конструкции Markdown.
- В текущей реализации дополнительных санитайзеров Markdown нет; при необходимости добавляется отдельный шаг санитации.

### 8) Расширение (как добавлять новые правила парсинга)
- Добавлять новые фильтры/экстракцию в отдельный модуль, например `src/services/response_postprocessor.py`, который будет:
  - Принимать «сырой» `result` Responses API.
  - Возвращать строку финального ответа и/или структуру с метаданными.
  - Обеспечивать конфигурируемые правила (блок-лист ключей, типы контента, предпочтения каналов).
- В `YandexAgentService` вызывать постпроцессор как зависимость (DIP), чтобы не менять существующую логику — только расширять.

### 9) Быстрый чек-лист для другого агента
- Если нужно поменять, что показываем пользователю:
  - Смотреть `src/services/yandex_agent_service.py` — блок разбора `result.output` и фильтров.
  - При добавлении сложных правил — вынести в отдельный модуль постпроцессинга и подключить через фабрику.
- Если не сохраняется контекст:
  - Проверить `src/ydb_client.py` и наличие `response_id` в ответах.
- Если ответ пустой/ошибка:
  - Проверить `result.error`, debug-файлы в `debug_logs/`, и логи `logger_service`.


