# Инструкция по разработке инструментов (Tools) для агента

## Общие принципы

### 1. Где делать инструменты: внутри проекта или облачные функции?

**✅ РЕКОМЕНДАЦИЯ: Делать инструменты внутри проекта**

**Почему:**
- Инструменты выполняются синхронно в контексте запроса агента
- Проще отладка и разработка (все в одном проекте)
- Меньше задержек (нет сетевых вызовов между сервисами)
- Проще управление версиями и деплоем (все в одном Docker-образе)
- Пример YC Wine Assistant показывает именно такой подход

**Когда использовать облачные функции:**
- Если инструмент требует долгого выполнения (>30 секунд)
- Если нужна независимая масштабируемость инструмента
- Если инструмент используется несколькими проектами

**Вывод:** Для вашего случая (чтение файлов из хранилища, HTTP-запросы к CRM) - делайте инструменты внутри проекта.

---

### 2. Где хранить JSON файлы: внутри проекта или в облачном хранилище?

**✅ РЕКОМЕНДАЦИЯ: Комбинированный подход**

**Внутри проекта (рекомендуется для):**
- Небольшие статичные файлы (<1 МБ)
- Файлы, которые редко меняются (список услуг, справочники)
- Файлы, нужные при старте приложения
- Пример: `services.json` с каталогом услуг

**В облачном хранилище (Object Storage):**
- Большие файлы (>1 МБ)
- Файлы, которые часто обновляются
- Файлы с конфиденциальными данными
- Файлы, которые не нужны при каждом запросе

**Вывод:** 
- `services.json` и подобные справочники → внутри проекта
- Большие файлы с данными → Object Storage (Yandex Object Storage)

---

## Архитектура инструментов

### Структура проекта

```
src/
  agents/
    tools/
      __init__.py          # Экспорт всех инструментов
      booking_tools.py     # Инструменты для бронирования
      crm_tools.py         # Инструменты для работы с CRM
      storage_tools.py     # Инструменты для работы с хранилищем
      ...
```

### Принципы SOLID

1. **Single Responsibility**: Один инструмент = одна задача
2. **Open/Closed**: Новые инструменты добавляются через новые классы, не изменяя существующие
3. **Dependency Inversion**: Инструменты зависят от абстракций (интерфейсов), а не от конкретных реализаций

---

## Шаблон создания инструмента

### Базовый шаблон

```python
"""
Описание модуля с инструментами
"""
from typing import Optional
from pydantic import BaseModel, Field
from yandex_cloud_ml_sdk._threads.thread import Thread


class YourToolName(BaseModel):
    """
    Краткое описание инструмента (это видит LLM)
    """
    
    # Обязательные параметры
    param1: str = Field(description="Описание параметра 1")
    
    # Необязательные параметры
    param2: Optional[str] = Field(description="Описание параметра 2", default=None)
    
    def process(self, thread: Thread) -> str:
        """
        Основная логика инструмента
        
        Args:
            thread: Thread для доступа к контексту диалога
            
        Returns:
            Строка с результатом выполнения (это увидит LLM)
        """
        try:
            # Ваша логика здесь
            result = self._do_something()
            
            # Возвращаем понятное сообщение для LLM
            return f"Успешно выполнено: {result}"
            
        except Exception as e:
            # Обработка ошибок
            return f"Ошибка при выполнении: {str(e)}"
    
    def _do_something(self):
        """Вспомогательный метод (приватный)"""
        # Реализация логики
        pass
```

---

## Типы инструментов

### 1. Инструменты для чтения данных из файлов

**Пример: Чтение JSON из файла проекта**

```python
import json
import os
from pathlib import Path
from typing import Optional
from pydantic import BaseModel, Field
from yandex_cloud_ml_sdk._threads.thread import Thread


class GetServiceList(BaseModel):
    """Получить список услуг из каталога"""
    
    category: Optional[str] = Field(
        description="Категория услуг (например, 'Маникюр')", 
        default=None
    )
    
    def process(self, thread: Thread) -> str:
        """Чтение списка услуг из JSON файла"""
        try:
            # Путь к файлу относительно корня проекта
            project_root = Path(__file__).parent.parent.parent.parent
            services_file = project_root / "services.json"
            
            if not services_file.exists():
                return "Файл с услугами не найден"
            
            with open(services_file, 'r', encoding='utf-8') as f:
                services_data = json.load(f)
            
            if self.category:
                # Фильтрация по категории
                for cat_id, cat_data in services_data.items():
                    if cat_data.get('category_name') == self.category:
                        services = cat_data.get('services', [])
                        return self._format_services(services)
                return f"Категория '{self.category}' не найдена"
            
            # Возвращаем все услуги
            all_services = []
            for cat_data in services_data.values():
                all_services.extend(cat_data.get('services', []))
            
            return self._format_services(all_services)
            
        except Exception as e:
            return f"Ошибка при чтении файла: {str(e)}"
    
    def _format_services(self, services: list) -> str:
        """Форматирование списка услуг для LLM"""
        if not services:
            return "Услуги не найдены"
        
        result = []
        for service in services:
            name = service.get('name', 'Неизвестно')
            price = service.get('prices', 'Не указана')
            result.append(f"- {name}: {price} руб.")
        
        return "\n".join(result)
```

**Пример: Чтение из Object Storage**

```python
import json
import os
import boto3
from typing import Optional
from pydantic import BaseModel, Field
from yandex_cloud_ml_sdk._threads.thread import Thread


class GetDataFromStorage(BaseModel):
    """Получить данные из облачного хранилища"""
    
    file_path: str = Field(description="Путь к файлу в хранилище (например, 'data/services.json')")
    
    def process(self, thread: Thread) -> str:
        """Чтение файла из Yandex Object Storage"""
        try:
            # Инициализация клиента Object Storage
            session = boto3.Session(
                aws_access_key_id=os.getenv('YC_ACCESS_KEY_ID'),
                aws_secret_access_key=os.getenv('YC_SECRET_ACCESS_KEY')
            )
            s3 = session.client(
                service_name='s3',
                endpoint_url='https://storage.yandexcloud.net'
            )
            
            bucket_name = os.getenv('YC_BUCKET_NAME')
            
            # Чтение файла
            response = s3.get_object(Bucket=bucket_name, Key=self.file_path)
            content = response['Body'].read().decode('utf-8')
            
            # Парсинг JSON
            data = json.loads(content)
            
            return f"Данные успешно загружены: {len(data)} записей"
            
        except Exception as e:
            return f"Ошибка при чтении из хранилища: {str(e)}"
```

---

### 2. Инструменты для работы с CRM через HTTP

**Пример: Запрос к CRM API**

```python
import os
import requests
from typing import Optional
from pydantic import BaseModel, Field
from yandex_cloud_ml_sdk._threads.thread import Thread


class CreateCRMRecord(BaseModel):
    """Создать запись в CRM системе"""
    
    name: str = Field(description="Имя клиента")
    phone: str = Field(description="Телефон клиента")
    service: Optional[str] = Field(description="Название услуги", default=None)
    
    def process(self, thread: Thread) -> str:
        """Создание записи в CRM через HTTP API"""
        try:
            crm_url = os.getenv('CRM_API_URL')
            crm_token = os.getenv('CRM_API_TOKEN')
            
            if not crm_url or not crm_token:
                return "CRM API не настроен (отсутствуют переменные окружения)"
            
            # Подготовка данных
            payload = {
                'name': self.name,
                'phone': self.phone,
                'service': self.service
            }
            
            headers = {
                'Authorization': f'Bearer {crm_token}',
                'Content-Type': 'application/json'
            }
            
            # HTTP запрос
            response = requests.post(
                f"{crm_url}/api/records",
                json=payload,
                headers=headers,
                timeout=10
            )
            
            response.raise_for_status()
            result = response.json()
            
            record_id = result.get('id', 'неизвестен')
            return f"Запись создана в CRM. ID: {record_id}"
            
        except requests.exceptions.RequestException as e:
            return f"Ошибка при обращении к CRM: {str(e)}"
        except Exception as e:
            return f"Неожиданная ошибка: {str(e)}"


class GetCRMRecord(BaseModel):
    """Получить запись из CRM системы"""
    
    record_id: str = Field(description="ID записи в CRM")
    
    def process(self, thread: Thread) -> str:
        """Получение записи из CRM"""
        try:
            crm_url = os.getenv('CRM_API_URL')
            crm_token = os.getenv('CRM_API_TOKEN')
            
            headers = {
                'Authorization': f'Bearer {crm_token}',
                'Content-Type': 'application/json'
            }
            
            response = requests.get(
                f"{crm_url}/api/records/{self.record_id}",
                headers=headers,
                timeout=10
            )
            
            response.raise_for_status()
            record = response.json()
            
            return (
                f"Запись найдена:\n"
                f"Имя: {record.get('name')}\n"
                f"Телефон: {record.get('phone')}\n"
                f"Услуга: {record.get('service', 'Не указана')}"
            )
            
        except requests.exceptions.HTTPError as e:
            if e.response.status_code == 404:
                return f"Запись с ID {self.record_id} не найдена"
            return f"Ошибка HTTP: {str(e)}"
        except Exception as e:
            return f"Ошибка при получении записи: {str(e)}"
```

---

## Регистрация инструментов

### 1. Экспорт в __init__.py

```python
"""
Инструменты для работы с CRM
"""
from .crm_tools import (
    CreateCRMRecord,
    GetCRMRecord,
    UpdateCRMRecord
)

__all__ = [
    "CreateCRMRecord",
    "GetCRMRecord",
    "UpdateCRMRecord"
]
```

### 2. Использование в агенте

```python
from src.agents.tools.crm_tools import CreateCRMRecord, GetCRMRecord
from src.agents.tools.storage_tools import GetServiceList

class BookingAgent(BaseAgent):
    """Агент для бронирования"""
    
    instruction = """
    Ты - помощник по бронированию услуг.
    Используй инструменты для работы с CRM и получения списка услуг.
    """
    
    def __init__(self, langgraph_service: LangGraphService):
        super().__init__(
            langgraph_service=langgraph_service,
            instruction=self.instruction,
            tools=[
                GetServiceList,      # Чтение из файла
                CreateCRMRecord,     # HTTP запрос к CRM
                GetCRMRecord         # HTTP запрос к CRM
            ],
            agent_name="BookingAgent"
        )
```

---

## Рекомендации по разработке

### 1. Обработка ошибок

**Всегда обрабатывайте ошибки и возвращайте понятные сообщения:**

```python
def process(self, thread: Thread) -> str:
    try:
        # Логика
        return "Успешный результат"
    except FileNotFoundError:
        return "Файл не найден"
    except json.JSONDecodeError:
        return "Ошибка формата JSON"
    except requests.exceptions.Timeout:
        return "Превышено время ожидания ответа от сервера"
    except Exception as e:
        # Логируем для отладки
        logger.error(f"Ошибка в {self.__class__.__name__}: {e}")
        return f"Произошла ошибка: {str(e)}"
```

### 2. Валидация входных данных

**Используйте Pydantic для валидации:**

```python
from pydantic import BaseModel, Field, validator

class CreateBooking(BaseModel):
    date: str = Field(description="Дата в формате YYYY-MM-DD")
    time: str = Field(description="Время в формате HH:MM")
    
    @validator('date')
    def validate_date(cls, v):
        # Проверка формата даты
        from datetime import datetime
        try:
            datetime.strptime(v, '%Y-%m-%d')
            return v
        except ValueError:
            raise ValueError('Неверный формат даты. Используйте YYYY-MM-DD')
```

### 3. Кэширование данных

**Для часто используемых данных:**

```python
from functools import lru_cache

class GetServiceList(BaseModel):
    @staticmethod
    @lru_cache(maxsize=1)
    def _load_services():
        """Кэшированная загрузка услуг"""
        with open('services.json', 'r', encoding='utf-8') as f:
            return json.load(f)
    
    def process(self, thread: Thread) -> str:
        services = self._load_services()  # Будет закэшировано
        # ...
```

### 4. Логирование

**Используйте logger для отладки:**

```python
from src.services.logger_service import logger

def process(self, thread: Thread) -> str:
    logger.info(f"Вызов инструмента {self.__class__.__name__}")
    try:
        result = self._do_work()
        logger.success(f"Инструмент выполнен успешно")
        return result
    except Exception as e:
        logger.error(f"Ошибка в инструменте: {e}")
        return f"Ошибка: {str(e)}"
```

---

## Структура файлов для хранения данных

### Рекомендуемая структура:

```
project_root/
  services.json              # Справочник услуг (внутри проекта)
  data/                      # Статические данные
    services/
      services.json          # Альтернативное расположение
      categories.json
    config/
      settings.json
  src/
    agents/
      tools/
        __init__.py
        booking_tools.py
        crm_tools.py
        storage_tools.py
```

---

## Переменные окружения

### Для работы с Object Storage:

```env
YC_ACCESS_KEY_ID=your_access_key
YC_SECRET_ACCESS_KEY=your_secret_key
YC_BUCKET_NAME=your-bucket-name
```

### Для работы с CRM:

```env
CRM_API_URL=https://api.crm.example.com
CRM_API_TOKEN=your_api_token
```

---

## Чеклист при создании нового инструмента

- [ ] Создан класс, наследующийся от `BaseModel`
- [ ] Добавлено описание класса (docstring) для LLM
- [ ] Все параметры имеют описания через `Field(description=...)`
- [ ] Реализован метод `process(self, thread: Thread) -> str`
- [ ] Добавлена обработка ошибок
- [ ] Инструмент экспортирован в `__init__.py`
- [ ] Добавлено логирование важных операций
- [ ] Протестирован вручную
- [ ] Документирован в комментариях

---

## Примеры из проекта

### Существующие инструменты:

- `src/agents/tools/booking_tools.py` - примеры инструментов для бронирования
- `YC Wine Assistant/advanced-assistant.ipynb` - примеры от Яндекса

### Использование:

- `src/agents/base_agent.py` - как инструменты передаются в агента
- `prompt_manager/app.py` - как инструменты регистрируются при создании агента

---

## Итоговые рекомендации

1. **Инструменты делайте внутри проекта** - проще, быстрее, надежнее
2. **Небольшие JSON файлы храните в проекте** - `services.json` и подобные
3. **Большие или часто меняющиеся файлы - в Object Storage**
4. **HTTP запросы к CRM делайте напрямую из инструмента** - используйте `requests`
5. **Следуйте принципам SOLID** - один инструмент = один файл = одна задача
6. **Всегда обрабатывайте ошибки** - возвращайте понятные сообщения для LLM
7. **Используйте типизацию** - Pydantic автоматически валидирует входные данные

